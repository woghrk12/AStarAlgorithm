# 📌 프로젝트 소개

최적화 과정 : https://memmaeranger.tistory.com/30

이 프로젝트는 Unity 기반의 실시간 게임에서 A* 알고리즘을 적용할 때 발생하는 성능 문제를 해결하기 위한 개선 실험입니다.

기존 프로젝트에서는 다수의 캐릭터가 동시에 경로를 계산할 경우, 기본 A* 알고리즘의 전체 맵 탐색 특성 때문에 프레임 드랍과 멈춤 현상이 발생했습니다.
이를 해결하기 위해 맵을 여러 개의 Region(구역)으로 분할한 후, **계층적 경로 탐색 방식**을 도입했습니다.

- **1단계** : Region 단위로 최적 경로를 탐색합니다. (`Region.cs`, `FindRegionPath()`)
- **2단계** : 해당 Region 내부에서 A* 알고리즘을 수행합니다. (`FindPathWithRegion()`, `FindPathToOtherRegion()`, `FindPathInRegion()`)

이 방식을 통해 전체 노드 집합 중 일부만 탐색 대상에 포함되어 실제로 **노드 방문 수가 기존 대비 최대 20% 수준으로 감소**하는 성능 개선 효과를 확인했습니다.

이 프로젝트는 다음 세 가지 목표를 중심으로 설계되었습니다.
1. 기존 A* 알고리즘 구조의 이해 및 구현
2. 실제 게임에서 발생하는 경로 탐색 병목 문제 재현
3. 구역 기반 계층적 탐색 구조 설계 및 실험

# 📖 A\* 알고리즘 구현 구조
이 프로젝트에서 A\* 알고리즘은 기본적으로 8방향 탐색을 지원하는 방식으로 구현되었습니다.
핵심 구현 로직은 `PathFindingController.cs`에 포함되어 있으며, 아래 구조를 따릅니다.

## ✔️ 주요 구성 요소
### 1️⃣ 노드 정보 (`Node.cs`)
- `G`, `H`, `F` 값을 포함하여 경로 탐색에 필요한 상태를 저장
- `CompareTo()` 구현을 통해 우선순위 큐에서 정렬 기준으로 사용

### 2️⃣ 우선순위 큐 (`PriorityQueue.cs`)
- `List<T>` 기반 이진 힙 구조로 직접 구현
- A\* 탐색에서 가장 `F` 값이 작은 노드를 효율적으로 선택

### 3️⃣ 기본 A\* 탐색 흐름 (`FindPath` 함수)
1. 시작 노드를 큐에 삽입
2. 큐에서 `F` 값이 가장 작은 노드를 반환
3. 목표 노드에 도달할 때까지 인접 노드 탐색 및 큐 갱신 반복
4. 경로 역추적 후 반환

## ✔️ 고려한 현실 요소
- 벽 충돌 감지 : `Physics2D.OverlapCircle()`을 활용하여 벽 여부 판단 (`TagAndLayer.Layer.WallCollider`)
- 이동 비용 차등 적용 : 직선 이동 시 10, 대각선 이동 시 14의 비용 적용

# 📊 문제의식 및 개선 아이디어
## ❗ 문제의식
기본 A\* 알고리즘은 맵 전체를 탐색 대상으로 하기 때문에, 실시간 게임에서 **다수의 오브젝트가 동시에 A\* 알고리즘을 수행할 경우 큰 성능 부담**이 발생합니다.

특히, 실제 사이드 프로젝트에서 몬스터 수십 마리가 동시에 경로를 계산하면서 **프레임이 멈추는 문제**를 직접 경험했습니다.
- 전체 맵을 탐색 대상으로 함 -> 목표 위치와 관계없는 먼 노드까지 모두 평가 대상에 포함됨
- 탐색 대상 필터링 부재 -> 필요 이상의 노드를 열고 닫으며, 효율성 저하
- A* 연산은 노드 수에 비례해 선형 또는 그 이상으로 증가

## 💡 개선 아이디어 : 구역 기반 계층적 A*
이 문제를 해결하기 위해 다음과 같은 아이디어를 적용했습니다.

### 1️⃣ 맵을 Region 단위로 나눈다 (`Region.cs`)
- 전체 맵을 사전에 Region 단위로 나누고, 각 Region의 위치 정보와 인접 Region 정보를 미리 설정해둡니다.
- Region 간 탐색은 도드 단위가 아닌, **Region 중심 좌표 간 거리**를 기준으로 수행됩니다.

### 2️⃣ A* 알고리즘을 두 단계로 나눈다 (분할 정복 기법 적용)
#### 1단계 : Region 단위의 A\* 탐색 (`FindRegionPath()`)
- 출발 Region부터 도착 Region까지 가장 효율적인 Region 경로를 찾습니다.
- 노드 단위가 아닌 Region 단위이므로 탐색 범위가 급격히 줄어듭니다.

#### 2단계 : 각 Region 내에서 노드 단위의 A\* 탐색 (`FindPathWithRegion()`)
- 현재 위치한 Region 내부에서만 노드 단위의 A\*를 수행합니다.
- 다음 Region에 도착하면 해당 Region을 새로운 타겟으로 설정하고 다시 노드 단위의 A\*를 수행합니다.

# 📊 실험 결과 및 성능 비교
개선된 Region 기반 A* 알고리즘이 실제로 얼마나 효과적인지 확인하기 위해, 기존 A* 방식과 개선 방식 모두 동일한 조건에서 테스트를 진행했습니다.
- 동일한 시작 위치(Start)와 목표 위치(Target) 설정
- 맵은 실제 게임 프로젝트에서 사용된 복잡한 맵
- 두 방식 모두 유니티 에디터에서 `F2`, `F3` 키를 통해 직접 실행
- 결과는 알고리즘을 수행하면서 방문한 노드 수와 생성된 경로의 길이를 디버그 콘솔에 출력

## Test 1
1. 기존 A* 알고리즘
  - \# nodes of path : 181
  - \# nodes of being visited : 3714
2. Region 기반 A* 알고리즘
  - \# nodes of path : 184 (기존 대비 101.6%)
  - \# nodes of being visited : 718 (기존 대비 19.3%)
<p align="center">
<img width="945" height="427" alt="image" src="https://github.com/user-attachments/assets/a5544d79-1cf0-4784-a30e-514b66292d29" />
</p>

## Test 2
1. 기존 A* 알고리즘
  - \# nodes of path : 140
  - \# nodes of being visited : 2370 
2. Region 기반 A* 알고리즘
  - \# nodes of path : 143 (기존 대비 102.1%)
  - \# nodes of being visited : 560 (기존 대비 23.6%)
<p align="center">
<img width="560" height="593" alt="image" src="https://github.com/user-attachments/assets/20afa84f-31d5-4ac2-922b-d0dfbc9baf05" />
</p>

# ✅ 결론
- 노드 방문 수가 줄어들어 경로 탐색 비용이 감소
- 이로 인해 동시에 여러 유닛이 A\*를 수행하더라도 프레임 유지 가능
- Region 단위로 경로를 재활용하거나, **Region 수준 캐싱** 등의 추가 확장이 가능

  
